name: ci

on:
  push:
    branches:
      - main
  pull_request:

env:
  # secrets.GITHUB_TOKEN is provided by GitHub Actions and not
  # bound to a personal user account. It allows for 1000
  # GitHub HTTP API requests per hour. A personal token
  # allows for 5000 of those.
  GITHUB_API_TOKEN: ${{ secrets.PERSONAL_GITHUB_API_TOKEN }}

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - name: Install linting dependencies
        run: pip install -r requirements-dev.txt
      - name: lint
        run: make lint-ci

  testsuite:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: Run `make tests`
        run: make tests

  # This is to confirm that commonly used developer commands still work.
  dev-cmds:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"
      - name: rebuild-expected-api-docs
        run: |
          pip install black
          make rebuild-expected-api-docs
      # Launch application as containerized stack. This terminates after
      # health checks confirm that stack is running.
      - name: run-app-bg
        run: make run-app-bg
      # Run `db-populate` twice to see that this can be repeated w/o failing.
      - name: test `make db-populate`, twice
        run: |
            pip install requests # the nonly non-stdlib dependency as of now
            export CONBENCH_BASE_URL=http://$(docker compose port app 5000) && \
            make db-populate && make db-populate
            docker-compose logs # view logs to see why transient errs happen
      - name: test `make teardown-app`
        run: make teardown-app
      # The goal of this is to largely test `make run-app-dev`.
      - name: test-run-app-dev
        run: make test-run-app-dev

  ui-screenshots:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: run-app-bg
        run: make run-app-bg
      - name: populate DB & take screenshots
        run: |
            pip install requests # the nonly non-stdlib dependency as of now
            export CONBENCH_BASE_URL=http://$(docker compose port app 5000)
            export SOME_BENCHMARK_ID="$(make -s db-populate)"
            echo "conbench base URL: $CONBENCH_BASE_URL"
            echo "a valid benchmark ID: $SOME_BENCHMARK_ID"
            cd ci
            docker build . -t conbench-screenshot -f screenshot.Dockerfile
            mkdir ci-artifacts
            docker run --net=host -v $(pwd)/ci-artifacts:/artifacts conbench-screenshot \
                python screenshot.py ${CONBENCH_BASE_URL} /artifacts frontpage
            docker run --net=host -v $(pwd)/ci-artifacts:/artifacts conbench-screenshot \
                python screenshot.py "${CONBENCH_BASE_URL}/benchmarks/${SOME_BENCHMARK_ID}/" \
                  /artifacts benchmark-result-view --wait-for-canvas
            /bin/ls -ahltr ci-artifacts/
      - name: upload-artifacts
        uses: actions/upload-artifact@v3
        # Upload screenshots _especially_ when result was unexpected.
        if: always()
        with:
          name: screenshots
          path: ci/ci-artifacts/
      - name: get container logs
        if: always()
        # If the browser-initiated GET requests led to e.g an Internal Server Error
        # then we see that in the screenshot(s). For debugging that, however,
        # it's crucial to get web application logs. Note that this shows
        # container logs interleaved, but prefixed so that it's after all
        # unambiguous which line came from which container.
        run: docker compose logs --since 30m
      - name: test `make teardown-app`
        # Run teardown especially when previous step(s) failed, because here
        # we get some good log output for debuggability.
        if: always()
        run: make teardown-app

  db-migrations:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: Start PostgreSQL DB
        run: docker compose run --detach db
      # Run `alembic upgrade head` via docker compose. This runs in the web
      # application container image. Running this via docker compose makes it
      # so that it is within the virtual network that the DB is also in,
      # reachable via DNS name `db`. Set CREATE_ALL_TABLES=false to defuse some
      # webapp bootstrap code (not needed here, because these Python modules
      # run in the context of alembic, not in the context of the actual web
      # application bootstrapping itself).
      - name: Test database migrations
        run: make set-build-info && docker compose run -e CREATE_ALL_TABLES app alembic upgrade head
        env:
          CREATE_ALL_TABLES: false

  libraries:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"
      - name: Install dependencies
        run: |
          # in order of dependency
          pip install \
            -e './benchclients/python[dev]' \
            -e ./benchadapt/python \
            -e ./benchconnect \
            -e ./benchrun/python
      - name: Test benchclients
        run: |
          pytest -vv benchclients/python/tests
      - name: Test benchadapt
        run: |
          pytest -vv benchadapt/python/tests
      - name: Test benchrun
        run: |
          pytest -vv benchrun/python/tests
      - name: Test benchconnect
        run: |
          pytest -vv benchconnect

  cb-on-minikube:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: start minikube
        id: minikube
        uses: medyagh/setup-minikube@latest
        with:
          kubernetes-version: v1.24.10
          # from https://github.com/prometheus-operator/kube-prometheus#minikube
          extra-config: kubelet.authentication-token-webhook=true,kubelet.authorization-mode=Webhook,scheduler.bind-address=0.0.0.0,controller-manager.bind-address=0.0.0.0
          cpus: max
          memory: max
      - name: ci/minikube/test-conbench-on-mk.sh
        run: export CONBENCH_REPO_ROOT_DIR=$(pwd) && bash ci/minikube/test-conbench-on-mk.sh

  deploy-packages:
    runs-on: ubuntu-latest
    # This workflow runs on pull requests and pushes to main. This job will only be run
    # on pushes to main.
    if: github.event_name == 'push'
    needs:
      - lint
      - testsuite
      - dev-cmds
      - ui-screenshots
      - db-migrations
      - libraries
      - cb-on-minikube
    matrix:
      include:
        - pkg_name: benchadapt
          pkg_root: ./benchadapt/python
        - pkg_name: benchclients
          pkg_root: ./benchclients/python
        - pkg_name: benchconnect
          pkg_root: ./benchconnect
        - pkg_name: benchrun
          pkg_root: ./benchrun/python
        - pkg_name: conbench
          pkg_root: .
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - name: Determine whether version changed
        id: check
        run: |
          # Get this package's current version
          cd ${{ matrix.pkg_root }}/${{ matrix.pkg_name }}
          version=$(
            python -c 'from _version import __version__; print(__version__)'
          )

          # Try to get information from PyPI about this package version
          pypi_message=$(
            curl https://pypi.org/pypi/${{ matrix.pkg_name }}/${version}/json \
            | jq '.message' \
            | tr -d '"'
          )

          if [[ $pypi_message = 'Not Found' ]]; then
            echo "Releasing new ${{ matrix.pkg_name }} version $version"
            echo 'release=true' >> $GITHUB_OUTPUT
            echo "version=$version" >> $GITHUB_OUTPUT
          else
            echo "${{ matrix.pkg_name }} version $version is already released to PyPI"
            echo 'release=false' >> $GITHUB_OUTPUT
          fi
      - name: Install python dependencies
        if: steps.check.outputs.release == 'true'
        run: python -m pip install -U build twine
      - name: Build wheel
        if: steps.check.outputs.release == 'true'
        run: |
          cd ${{ matrix.pkg_root }}
          python -m build
      - name: Upload to PyPI
        if: steps.check.outputs.release == 'true'
        env:
          TWINE_USERNAME: ${{ secrets.TWINE_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.TWINE_PASSWORD }}
        run: |
          cd ${{ matrix.pkg_root }}
          python -m twine upload dist/* --non-interactive
      - name: Tag this commit
        if: steps.check.outputs.release == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ matrix.pkg_name }}-${{ steps.check.outputs.version }}',
              sha: context.sha
            })
