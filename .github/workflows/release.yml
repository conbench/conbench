name: Build and upload a package to PyPI

on:
  workflow_dispatch:
    inputs:
      package:
        description: Package to build and upload
        required: true
        type: choice
        options:
          - benchadapt
          - benchclients
          - benchconnect
          - benchrun
          - conbench
      version_suffix:
        description: Optional suffix if there's >1 release today. Recommended to leave blank.
        required: false
        type: string

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repo
        uses: actions/checkout@v3
      - name: Define some variables to use later
        id: variables
        run: |
          # Generate the new version number (YYYY.m.d, from the date in UTC)
          # We don't want zero-padding. Use space-padding, then delete the spaces.
          version=$(date -u +'%Y.%_m.%_d' | sed 's/ //g')

          # If there's already been a release today, append the suffix. This should be rare.
          if [[ '${{ inputs.version_suffix }}' ]]; then
            version="${version}.${{ inputs.version_suffix }}"
          fi

          echo "Generated version number: $version"
          echo "version=$version" >> $GITHUB_OUTPUT

          # Find package root dir
          if [[ '${{ inputs.package }}' = 'benchadapt' ]]; then
            pkg_root=./benchadapt/python
          elif [[ '${{ inputs.package }}' = 'benchclients' ]]; then
            pkg_root=./benchclients/python
          elif [[ '${{ inputs.package }}' = 'benchconnect' ]]; then
            pkg_root=./benchconnect
          elif [[ '${{ inputs.package }}' = 'benchrun' ]]; then
            pkg_root=./benchrun/python
          elif [[ '${{ inputs.package }}' = 'conbench' ]]; then
            pkg_root=.
          fi
          echo "Package root: $pkg_root"
          echo "pkg_root=$pkg_root" >> $GITHUB_OUTPUT

          # Find version file (standardized for all packages in this repo)
          version_file="${pkg_root}/${{ inputs.package }}/_version.py"
          echo "Version file to update: $version_file"
          echo "version_file=$version_file" >> $GITHUB_OUTPUT

          # Generate a branch name
          branch_name="benchbot/${{ inputs.package }}-${version}"
          echo "Branch name: $branch_name"
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT

          # Generate a commit message
          commit_msg="ðŸ¤– ci: bump version of ${{ inputs.package }} to $version"
          echo "Commit message: $commit_msg"
          echo "commit_msg='$commit_msg'" >> $GITHUB_OUTPUT
      - name: Replace version file
        run: |
          old_file_contents=$(cat ${{ steps.variables.outputs.version_file }})
          new_file_contents='# Do not touch this autogenerated file\n__version__ = "${{ steps.variables.outputs.version }}"'

          if [[ "$old_file_contents" = "$new_file_contents" ]]; then
            echo 'Version file would not change. Was there already a release today?'
            echo 'If necessary, release again with `version_suffix` set.'
            exit 1
          fi

          echo $new_file_contents > ${{ steps.variables.outputs.version_file }}
      - name: Commit to a branch
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git checkout -B ${{ steps.variables.outputs.branch_name }}
          git add ${{ steps.variables.outputs.version_file }}
          git commit -m '${{ steps.variables.outputs.commit_msg }}'
          git push
      - name: Open and merge a PR
        uses: actions/github-script@v6
        with:
          script: |
            // We could push directly to main, but this may be more auditable and allow
            // us to discuss the release further on the PR
            const pull = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '${{ steps.variables.outputs.commit_msg }}',
              head: '${{ steps.variables.outputs.branch_name }}',
              base: 'main',
              body: 'Beep, boop. I am a bot, requested to open this PR in preparation to release to PyPI.'
            })

            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pull.number
            })
      - name: Sync local repo to main branch
        id: get_commit
        run: |
          git checkout main
          git pull origin
          upload_commit=$(git rev-parse HEAD)
          echo "Commit that will be uploaded: $upload_commit"
          echo "upload_commit=$upload_commit" >> $GITHUB_OUTPUT
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - name: Install python dependencies
        run: python -m pip install -U build twine
      - name: Build wheel
        run: |
          cd ${{ steps.variables.outputs.pkg_root }}
          python -m build
      - name: Upload to PyPI
        env:
          TWINE_USERNAME: ${{ secrets.TWINE_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.TWINE_PASSWORD }}
        run: |
          cd ${{ steps.variables.outputs.pkg_root }}
          python -m twine upload dist/* --non-interactive
      - name: Tag this commit
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ inputs.package }}-${{ steps.variables.outputs.version }}',
              sha: '${{ steps.get_commit.outputs.upload_commit }}'
            })
